= Connecting to a Database
:navtitle: Connecting to a Database

在本节中，我们将部署和连接 MongoDB 数据库，nationalparks应用程序将在其中存储位置信息。

最后，我们将nationalparks应用程序标记为地图可视化工具的后端，以便parksmap 组件可以使用 OpenShift 发现机制对其进行动态发现，并自动显示地图。

Finally, we will mark the `nationalparks` application as a backend for the map
visualization tool, so that it can be dynamically discovered by the `parksmap`
component using the OpenShift discovery mechanism and the map will be displayed
automatically.

image::roadshow-app-architecture-nationalparks-2.png[Application architecture,800,align="center"]

[#storage]
== Background: Storage

大多数应用程序在某种程度上是“有状态的”或“动态的”，这通常是通过数据库或其他数据存储来实现的。在本实验中，我们将把 MongoDB 添加到我们的nationalparks应用程序中，然后重新连接它以通过 secret 使用环境变量与数据库通信。

我们将使用 OpenShift 附带的 MongoDB 映像。

默认情况下，使用 EmptyDir 进行数据存储，这意味着如果Pod 消失，数据也会消失。在实际应用程序中，您将使用 OpenShift 的持久性存储机制将存储（NFS、Ceph、EBS、iSCSI 等）附加到Pod，从而为它们提供一个持久的位置来存储其数据。

[#templates]
== Background: Templates

在本模块中，我们将从模板 Template 创建 MongoDB ，这是 OpenShift 中用于为某些值定义参数的有用方法，例如数据库用户名或密码，这些值可以由 OpenShift 在处理时自动生成。

管理员可以将模板加载到 OpenShift 中并使所有用户都可以使用它们。用户可以创建模板并将其加载到自己的项目中，以供其他用户（具有访问权限）共享和使用。

模板重要意义在于，他们可以通过提供一个可以用一条命令部署“配置参数”，加快应用开发的部署流程。不仅如此，它们还可以从外部 URL 加载到 OpenShift 中，这将允许您将模板保存在版本控制系统中。

[#create_mongodb_template]
== Exercise: Create a MongoDB Template

NOTE: If you are using https://developers.redhat.com/developer-sandbox[Developer Sandbox for Red Hat OpenShift,window='_blank'], you can *skip* this section and jump to the next one called *Exercise: Deploy MongoDB* because MongoDB Template it's already available on Developer Sandbox.

In this step we will create a MongoDB template inside our project, so that is only visible to our user and we can access it from Developer Perspective to create a MongoDB instance.

[.console-input]
[source,bash,subs="+attributes,macros+"]
----
oc create -f +https://raw.githubusercontent.com/openshift-labs/starter-guides/ocp-4.6/mongodb-template.yaml+ -n %PROJECT%
----

What just happened? What did you just `create`? The item that we passed to the `create`
command is a *Template*. `create` simply makes the template available in
your *Project*.

[#deploy_mongodb]
== Exercise: Deploy MongoDB

正如您目前所见，Web 控制台可以非常轻松地将内容部署到 OpenShift。当我们部署数据库时，我们传入一些值进行配置。这些值用于设置数据库的用户名、密码和名称。

数据库映像的构建方式将使用提供的信息自动配置自己（假设持久存储中没有数据！）。该镜像将确保：

- 存在具有指定名称的数据库 A database exists with the specified name
- 存在具有指定名称的用户   A user exists with the specified name
- 用户可以使用指定的密码访问指定的数据库 The user can access the specified database with the specified password

在workshop项目的开发者视图中，单击+Add然后单击Database。在数据库视图中，您可以单击Mongo以仅过滤 MongoDB。

NOTE: Make sure to uncheck *Operator Backed* option from *Type* section

image::nationalparks-databases-catalog-databases.png[Data Stores]

Alternatively, you could type `mongodb` in the search box. Once you have drilled down to see MongoDB, find the *MongoDB (Ephemeral)* template and select it.  You will notice that there are multiple
MongoDB templates available.  We do not need a database with persistent storage, so the ephemeral Mongo
template is what you should choose.  Go ahead and select the ephemeral template and click the *Instantiate Template* button.

When we performed the application build, there was no template. Rather, we selected the
builder image directly and OpenShift presented only the standard build workflow.
Now we are using a template - a preconfigured set of resources that includes
parameters that can be customized. In our case, the parameters we are concerned
with are -- user, password, database, and
admin password.

image::nationalparks-databases-catalog-databases-mongodb-config.png[MongoDB Deploy]

CAUTION: Make sure you name your database service name *mongodb-nationalparks*

You can see that some of the fields say *"generated if empty"*. This is a
feature of *Templates* in OpenShift. For
now, be sure to use the following values in their respective fields:

*Database Service Name*:
[source,role=copypaste]
----
mongodb-nationalparks
----

*MongoDB Connection Username*:
[source,role=copypaste]
----
mongodb
----

*MongoDB Connection Password*:
[source,role=copypaste]
----
mongodb
----

*MongoDB Database Name*:
[source,role=copypaste]
----
mongodb
----

*MongoDB Admin Password*:
[source,role=copypaste]
----
mongodb
----

CAUTION: Make sure to have configured the *`MongoDB Database Name`* parameter with the appropriate value as by default it will already have a value of `sampledb`.

Once you have entered in the above information, click on *Create* to go to the next step which will allow us to add a binding.

From left-side menu, click to *Secrets*.

image::nationalparks-databases-list-secrets.png[List Secrets]

Click the secret name listed that we will use for *Parameters*. The secret can be used in other components, such as the `nationalparks` backend, to authenticate to the database.

Now that the connection and authentication information stored in a secret in our project, we need to add it to the `nationalparks` backend. Click the *Add Secret to Workload* button.

image::nationalparks-databases-binding-view-secret.png[National Parks Binding]

Select the `nationalparks` workload and click *Save*.

image::nationalparks-databases-binding-add-binding-to-nationalparks.png[Add binding to application]

This change in configuration will trigger a new deployment of the `nationalparks` application with the environment variables properly injected.

[TIP]
====
Back in the *Topology* view, if your `mongodb-nationalparks` component is not already in the light gray area that denotes the `workshop` application, click and drag the component whilst holding down kbd:[Shift] to add it to the group with the other two components (as shown below)

image::nationalparks-databases-add-mongodb-to-workshop-app.png[Add mongodb to the workshop app]
====

Next, let's fix the labels assigned to the `mongodb-nationalparks` deployment. Currently, we cannot set labels when using the database template from the catalog, so we will fix these labels manually. 

Like before, we'll add 3 labels:

The name of the Application group:

[source,role=copypaste]
----
app=workshop
----

Next the name of this deployment.

[source,role=copypaste]
----
component=nationalparks
----

And finally, the role this component plays in the overall application.

[source,role=copypaste]
----
role=database
----

Execute the following command:
[.console-input]
[source,bash,subs="+attributes,macros+"]
----
oc label dc/mongodb-nationalparks svc/mongodb-nationalparks app=workshop component=nationalparks role=database --overwrite
----

[#exploring_openshift_magic]
== Exercise: Exploring OpenShift Magic

As soon as we attached the Secret to the *Deployment*, some
magic happened. OpenShift decided that this was a significant enough change to
warrant updating the internal version number of the *ReplicaSet*. You
can verify this by looking at the output of `oc get rs`:

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME                       DESIRED   CURRENT   READY   AGE
nationalparks-58bd4758fc   0         0         0       4m58s
nationalparks-7445576cd9   0         0         0       6m42s
nationalparks-789c6bc4f4   1         1         1       41s
parksmap-57df75c46d        1         1         1       8m24s
parksmap-65c4f8b676        0         0         0       18m
----

We see that the DESIRED and CURRENT number of instances for the current deployment. The desired and current number of the other instances are 0.
This means that OpenShift has gracefully torn down our "old" application and
stood up a "new" instance.



[#data_data_everywhere]
== Exercise: Data, Data, Everywhere

Now that we have a database deployed, we can again visit the `nationalparks` web
service to query for data:

[source,role="copypaste",subs="+attributes"]
----
https://nationalparks-%PROJECT%.%CLUSTER_SUBDOMAIN%/ws/data/all
----

And the result?

[.console-output]
[source,bash]
----
[]
----

Where's the data? Think about the process you went through. You deployed the
application and then deployed the database. Nothing actually loaded anything
*INTO* the database, though.

The application provides an endpoint to do just that:

[source,role="copypaste",subs="+attributes"]
----
https://nationalparks-%PROJECT%.%CLUSTER_SUBDOMAIN%/ws/data/load
----

And the result?

[.console-output]
[source,bash]
----
Items inserted in database: 2893
----

If you then go back to `/ws/data/all` you will see tons of JSON data now.
That's great. Our parks map should finally work!

NOTE: There are some errors reported with browsers like Firefox 54 that don't properly parse the resulting JSON. It's
a browser problem, and the application is working properly.

[source,role="copypaste",subs="+attributes"]
----
https://parksmap-%PROJECT%.%CLUSTER_SUBDOMAIN%
----

Hmm... There's just one thing. The main map **STILL** isn't displaying the parks.
That's because the front end parks map only tries to talk to services that have
the right *Label*.

[NOTE]
====
You are probably wondering how the database connection magically started
working? When deploying applications to OpenShift, it is always best to use
environment variables, secrets, or configMaps to define connections to dependent systems.  This allows
for application portability across different environments.  The source file that
performs the connection as well as creates the database schema can be viewed
here:


[source,role="copypaste"]
----
http://www.github.com/openshift-roadshow/nationalparks/blob/master/src/main/java/com/openshift/evg/roadshow/parks/db/MongoDBConnection.java#L44-l48
----

In short summary: By referring to bindings to connect to services
(like databases), it can be trivial to promote applications throughout different
lifecycle environments on OpenShift without having to modify application code.

====

[#working_with_labels]
== Exercise: Working With Labels

We explored how a *Label* is just a key=value pair earlier when looking at
*Services* and *Routes* and *Selectors*. In general, a *Label* is simply an
arbitrary key=value pair. It could be anything.

* `pizza=pepperoni`
* `pet=dog`
* `openshift=awesome`

In the case of the parks map, the application is actually querying the OpenShift
API and asking about the *Routes* and *Services* in the project. If any of them have a
*Label* that is `type=parksmap-backend`, the application knows to interrogate
the endpoints to look for map data.
You can see the code that does this
link:https://github.com/openshift-roadshow/parksmap-web/blob/master/src/main/java/com/openshift/evg/roadshow/rest/RouteWatcher.java#L20[here].


Fortunately, the command line provides a convenient way for us to manipulate
labels. `describe` the `nationalparks` service:

[.console-input]
[source,bash,subs="+attributes,macros+"]
----
oc describe route nationalparks
----

[.console-output]
[source,bash,subs="+attributes,macros+"]
----
Name:                   nationalparks
Namespace:              %PROJECT%
Created:                2 hours ago
Labels:                 app=workshop
                        app.kubernetes.io/component=nationalparks
                        app.kubernetes.io/instance=nationalparks
                        app.kubernetes.io/name=java
                        app.kubernetes.io/part-of=workshop
                        app.openshift.io/runtime=java
                        app.openshift.io/runtime-version=11
                        component=nationalparks
                        role=backend  
Annotations:            openshift.io/host.generated=true                          
Requested Host:         nationalparks-%PROJECT%.%CLUSTER_SUBDOMAIN%
                        exposed on router router 2 hours ago
Path:                   <none>
TLS Termination:        <none>
Insecure Policy:        <none>
Endpoint Port:          8080-tcp

Service:                nationalparks
Weight:                 100 (100%)
Endpoints:              10.1.9.8:8080
----

You see that it already has some labels. Now, use `oc label`:

[.console-input]
[source,bash,subs="+attributes,macros+"]
----
oc label route nationalparks type=parksmap-backend
----

You will see something like:

[.console-output]
[source,bash]
----
route.route.openshift.io/nationalparks labeled
----

If you check your browser now:

[source,role="copypaste",subs="+attributes"]
----
https://parksmap-%PROJECT%.%CLUSTER_SUBDOMAIN%/
----

image::nationalparks-databases-new-parks.png[MongoDB]

You'll notice that the parks suddenly are showing up. That's really cool!
